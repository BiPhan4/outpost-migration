{
  "contract_name": "storage-outpost",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The message to instantiate the ICA controller contract.",
    "type": "object",
    "properties": {
      "admin": {
        "description": "The address of the admin of the ICA application. If not specified, the sender is the admin.",
        "type": [
          "string",
          "null"
        ]
      },
      "channel_open_init_options": {
        "description": "The options to initialize the IBC channel upon contract instantiation. If not specified, the IBC channel is not initialized, and the relayer must.",
        "anyOf": [
          {
            "$ref": "#/definitions/ChannelOpenInitOptions"
          },
          {
            "type": "null"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "ChannelOpenInitOptions": {
        "description": "The message used to provide the MsgChannelOpenInit with the required data.",
        "type": "object",
        "required": [
          "connection_id",
          "counterparty_connection_id"
        ],
        "properties": {
          "connection_id": {
            "description": "The connection id on this chain.",
            "type": "string"
          },
          "counterparty_connection_id": {
            "description": "The counterparty connection id on the counterparty chain.",
            "type": "string"
          },
          "counterparty_port_id": {
            "description": "The counterparty port id. If not specified, [crate::ibc::types::keys::HOST_PORT_ID] is used. Currently, this contract only supports the host port.",
            "type": [
              "string",
              "null"
            ]
          },
          "tx_encoding": {
            "description": "TxEncoding is the encoding used for the ICA txs. If not specified, [TxEncoding::Protobuf] is used.",
            "anyOf": [
              {
                "$ref": "#/definitions/TxEncoding"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "TxEncoding": {
        "description": "Encoding is the encoding of the transactions sent to the ICA host.",
        "oneOf": [
          {
            "description": "Protobuf is the protobuf serialization of the CosmosSDK's Any.",
            "type": "string",
            "enum": [
              "proto3"
            ]
          },
          {
            "description": "Proto3Json is the json serialization of the CosmosSDK's Any.",
            "type": "string",
            "enum": [
              "proto3json"
            ]
          }
        ]
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "The messages to execute the ICA controller contract.",
    "oneOf": [
      {
        "description": "CreateChannel makes the contract submit a stargate MsgChannelOpenInit to the chain. This is a wrapper around [`options::ChannelOpenInitOptions`] and thus requires the same fields.",
        "type": "object",
        "required": [
          "create_channel"
        ],
        "properties": {
          "create_channel": {
            "$ref": "#/definitions/ChannelOpenInitOptions"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "SendCustomIcaMessages sends custom messages from the ICA controller to the ICA host.",
        "type": "object",
        "required": [
          "send_custom_ica_messages"
        ],
        "properties": {
          "send_custom_ica_messages": {
            "type": "object",
            "required": [
              "messages"
            ],
            "properties": {
              "messages": {
                "description": "Base64-encoded json or proto messages to send to the ICA host.\n\n# Example JSON Message:\n\nThis is a legacy text governance proposal message serialized using proto3json.\n\n```json { \"messages\": [ { \"@type\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\", \"content\": { \"@type\": \"/cosmos.gov.v1beta1.TextProposal\", \"title\": \"IBC Gov Proposal\", \"description\": \"tokens for all!\" }, \"initial_deposit\": [{ \"denom\": \"stake\", \"amount\": \"5000\" }], \"proposer\": \"cosmos1k4epd6js8aa7fk4e5l7u6dwttxfarwu6yald9hlyckngv59syuyqnlqvk8\" } ] } ```\n\nwhere proposer is the ICA controller's address.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  }
                ]
              },
              "packet_memo": {
                "description": "Optional memo to include in the ibc packet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "timeout_seconds": {
                "description": "Optional timeout in seconds to include with the ibc packet. If not specified, the [default timeout](crate::ibc_module::types::packet::DEFAULT_TIMEOUT_SECONDS) is used.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "SendPredefinedAction sends a predefined action from the ICA controller to the ICA host. This demonstration is useful for contracts that have predefined actions such as DAOs.\n\nIn this example, the predefined action is a `MsgSend` message which sends 100 \"stake\" tokens.",
        "type": "object",
        "required": [
          "send_predefined_action"
        ],
        "properties": {
          "send_predefined_action": {
            "type": "object",
            "required": [
              "to_address"
            ],
            "properties": {
              "to_address": {
                "description": "The recipient's address, on the counterparty chain, to send the tokens to from ICA host.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "sending tokens with the protobuf encoding scheme",
        "type": "object",
        "required": [
          "send_coins_proto"
        ],
        "properties": {
          "send_coins_proto": {
            "type": "object",
            "required": [
              "recipient_address"
            ],
            "properties": {
              "recipient_address": {
                "description": "The recipient's address, on the counterparty chain, to send the tokens to from ICA host.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "ChannelOpenInitOptions": {
        "description": "The message used to provide the MsgChannelOpenInit with the required data.",
        "type": "object",
        "required": [
          "connection_id",
          "counterparty_connection_id"
        ],
        "properties": {
          "connection_id": {
            "description": "The connection id on this chain.",
            "type": "string"
          },
          "counterparty_connection_id": {
            "description": "The counterparty connection id on the counterparty chain.",
            "type": "string"
          },
          "counterparty_port_id": {
            "description": "The counterparty port id. If not specified, [crate::ibc::types::keys::HOST_PORT_ID] is used. Currently, this contract only supports the host port.",
            "type": [
              "string",
              "null"
            ]
          },
          "tx_encoding": {
            "description": "TxEncoding is the encoding used for the ICA txs. If not specified, [TxEncoding::Protobuf] is used.",
            "anyOf": [
              {
                "$ref": "#/definitions/TxEncoding"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "TxEncoding": {
        "description": "Encoding is the encoding of the transactions sent to the ICA host.",
        "oneOf": [
          {
            "description": "Protobuf is the protobuf serialization of the CosmosSDK's Any.",
            "type": "string",
            "enum": [
              "proto3"
            ]
          },
          {
            "description": "Proto3Json is the json serialization of the CosmosSDK's Any.",
            "type": "string",
            "enum": [
              "proto3json"
            ]
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "The messages to query the ICA controller contract.",
    "oneOf": [
      {
        "description": "GetChannel returns the IBC channel info.",
        "type": "object",
        "required": [
          "get_channel"
        ],
        "properties": {
          "get_channel": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "GetContractState returns the contact's state.",
        "type": "object",
        "required": [
          "get_contract_state"
        ],
        "properties": {
          "get_contract_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "GetCallbackCounter returns the callback counter.",
        "type": "object",
        "required": [
          "get_callback_counter"
        ],
        "properties": {
          "get_callback_counter": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "get_callback_counter": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CallbackCounter",
      "description": "CallbackCounter tracks the number of callbacks in store.",
      "type": "object",
      "required": [
        "error",
        "success",
        "timeout"
      ],
      "properties": {
        "error": {
          "description": "The number of erroneous callbacks.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "success": {
          "description": "The number of successful callbacks.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "timeout": {
          "description": "The number of timeout callbacks. The channel is closed after a timeout due to the semantics of ordered channels.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "get_channel": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChannelState",
      "description": "ContractChannelState is the state of the IBC application's channel. This application only supports one channel.",
      "type": "object",
      "required": [
        "channel",
        "channel_status"
      ],
      "properties": {
        "channel": {
          "description": "The IBC channel, as defined by cosmwasm.",
          "allOf": [
            {
              "$ref": "#/definitions/IbcChannel"
            }
          ]
        },
        "channel_status": {
          "description": "The status of the channel.",
          "allOf": [
            {
              "$ref": "#/definitions/ChannelStatus"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ChannelStatus": {
          "description": "ChannelState is the state of the IBC channel.",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN",
            "STATE_CLOSED"
          ]
        },
        "IbcChannel": {
          "description": "IbcChannel defines all information on a channel. This is generally used in the hand-shake process, but can be queried directly.",
          "type": "object",
          "required": [
            "connection_id",
            "counterparty_endpoint",
            "endpoint",
            "order",
            "version"
          ],
          "properties": {
            "connection_id": {
              "description": "The connection upon which this channel was created. If this is a multi-hop channel, we only expose the first hop.",
              "type": "string"
            },
            "counterparty_endpoint": {
              "$ref": "#/definitions/IbcEndpoint"
            },
            "endpoint": {
              "$ref": "#/definitions/IbcEndpoint"
            },
            "order": {
              "$ref": "#/definitions/IbcOrder"
            },
            "version": {
              "description": "Note: in ibcv3 this may be \"\", in the IbcOpenChannel handshake messages",
              "type": "string"
            }
          }
        },
        "IbcEndpoint": {
          "type": "object",
          "required": [
            "channel_id",
            "port_id"
          ],
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            }
          }
        },
        "IbcOrder": {
          "description": "IbcOrder defines if a channel is ORDERED or UNORDERED Values come from https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/core/channel/v1/channel.proto#L69-L80 Naming comes from the protobuf files and go translations.",
          "type": "string",
          "enum": [
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ]
        }
      }
    },
    "get_contract_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractState",
      "description": "ContractState is the state of the IBC application.",
      "type": "object",
      "required": [
        "admin"
      ],
      "properties": {
        "admin": {
          "description": "The address of the admin of the IBC application.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "allow_channel_open_init": {
          "description": "If true, the IBC application will accept `MsgChannelOpenInit` messages.",
          "default": false,
          "type": "boolean"
        },
        "ica_info": {
          "description": "The Interchain Account (ICA) info needed to send packets. This is set during the handshake.",
          "anyOf": [
            {
              "$ref": "#/definitions/IcaInfo"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "IcaInfo": {
          "description": "IcaInfo is the ICA address and channel ID.",
          "type": "object",
          "required": [
            "channel_id",
            "encoding",
            "ica_address"
          ],
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "encoding": {
              "$ref": "#/definitions/TxEncoding"
            },
            "ica_address": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "TxEncoding": {
          "description": "Encoding is the encoding of the transactions sent to the ICA host.",
          "oneOf": [
            {
              "description": "Protobuf is the protobuf serialization of the CosmosSDK's Any.",
              "type": "string",
              "enum": [
                "proto3"
              ]
            },
            {
              "description": "Proto3Json is the json serialization of the CosmosSDK's Any.",
              "type": "string",
              "enum": [
                "proto3json"
              ]
            }
          ]
        }
      }
    }
  }
}
