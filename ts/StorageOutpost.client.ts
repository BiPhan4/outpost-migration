/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Binary, TxEncoding, InstantiateMsg, Callback, ChannelOpenInitOptions, ExecuteMsg, CosmosMsgForEmpty, BankMsg, Uint128, IbcMsg, Timestamp, Uint64, WasmMsg, GovMsg, VoteOption, Decimal, Coin, Empty, IbcTimeout, IbcTimeoutBlock, WeightedVoteOption, QueryMsg, CallbackCounter, IbcOrder, ChannelStatus, ChannelState, IbcChannel, IbcEndpoint, Addr, ContractState, IcaInfo, Expiration, OwnershipForString } from "./StorageOutpost.types";
export interface StorageOutpostReadOnlyInterface {
  contractAddress: string;
  getChannel: () => Promise<ChannelState>;
  getContractState: () => Promise<ContractState>;
  getCallbackCounter: () => Promise<CallbackCounter>;
  ownership: () => Promise<OwnershipForString>;
}
export class StorageOutpostQueryClient implements StorageOutpostReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getChannel = this.getChannel.bind(this);
    this.getContractState = this.getContractState.bind(this);
    this.getCallbackCounter = this.getCallbackCounter.bind(this);
    this.ownership = this.ownership.bind(this);
  }

  getChannel = async (): Promise<ChannelState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_channel: {}
    });
  };
  getContractState = async (): Promise<ContractState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_contract_state: {}
    });
  };
  getCallbackCounter = async (): Promise<CallbackCounter> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_callback_counter: {}
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface StorageOutpostInterface extends StorageOutpostReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createChannel: ({
    connectionId,
    counterpartyConnectionId,
    counterpartyPortId,
    txEncoding
  }: {
    connectionId: string;
    counterpartyConnectionId: string;
    counterpartyPortId?: string;
    txEncoding?: TxEncoding;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createTransferChannel: ({
    connectionId,
    counterpartyConnectionId,
    counterpartyPortId,
    txEncoding
  }: {
    connectionId: string;
    counterpartyConnectionId: string;
    counterpartyPortId?: string;
    txEncoding?: TxEncoding;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendCosmosMsgs: ({
    messages,
    packetMemo,
    timeoutSeconds
  }: {
    messages: CosmosMsgForEmpty[];
    packetMemo?: string;
    timeoutSeconds?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendCosmosMsgsCli: ({
    packetMemo,
    path,
    timeoutSeconds
  }: {
    packetMemo?: string;
    path: string;
    timeoutSeconds?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendTransferMsg: ({
    packetMemo,
    recipient,
    timeoutSeconds
  }: {
    packetMemo?: string;
    recipient: string;
    timeoutSeconds?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class StorageOutpostClient extends StorageOutpostQueryClient implements StorageOutpostInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createChannel = this.createChannel.bind(this);
    this.createTransferChannel = this.createTransferChannel.bind(this);
    this.sendCosmosMsgs = this.sendCosmosMsgs.bind(this);
    this.sendCosmosMsgsCli = this.sendCosmosMsgsCli.bind(this);
    this.sendTransferMsg = this.sendTransferMsg.bind(this);
  }

  createChannel = async ({
    connectionId,
    counterpartyConnectionId,
    counterpartyPortId,
    txEncoding
  }: {
    connectionId: string;
    counterpartyConnectionId: string;
    counterpartyPortId?: string;
    txEncoding?: TxEncoding;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_channel: {
        connection_id: connectionId,
        counterparty_connection_id: counterpartyConnectionId,
        counterparty_port_id: counterpartyPortId,
        tx_encoding: txEncoding
      }
    }, fee, memo, _funds);
  };
  createTransferChannel = async ({
    connectionId,
    counterpartyConnectionId,
    counterpartyPortId,
    txEncoding
  }: {
    connectionId: string;
    counterpartyConnectionId: string;
    counterpartyPortId?: string;
    txEncoding?: TxEncoding;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_transfer_channel: {
        connection_id: connectionId,
        counterparty_connection_id: counterpartyConnectionId,
        counterparty_port_id: counterpartyPortId,
        tx_encoding: txEncoding
      }
    }, fee, memo, _funds);
  };
  sendCosmosMsgs = async ({
    messages,
    packetMemo,
    timeoutSeconds
  }: {
    messages: CosmosMsgForEmpty[];
    packetMemo?: string;
    timeoutSeconds?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_cosmos_msgs: {
        messages,
        packet_memo: packetMemo,
        timeout_seconds: timeoutSeconds
      }
    }, fee, memo, _funds);
  };
  sendCosmosMsgsCli = async ({
    packetMemo,
    path,
    timeoutSeconds
  }: {
    packetMemo?: string;
    path: string;
    timeoutSeconds?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_cosmos_msgs_cli: {
        packet_memo: packetMemo,
        path,
        timeout_seconds: timeoutSeconds
      }
    }, fee, memo, _funds);
  };
  sendTransferMsg = async ({
    packetMemo,
    recipient,
    timeoutSeconds
  }: {
    packetMemo?: string;
    recipient: string;
    timeoutSeconds?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_transfer_msg: {
        packet_memo: packetMemo,
        recipient,
        timeout_seconds: timeoutSeconds
      }
    }, fee, memo, _funds);
  };
}